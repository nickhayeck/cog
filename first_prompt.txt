Let's build a working prototype compiler for a Rust-syntax language with these constraints: no borrow checking, no lifetimes, no generics, no strict-aliasing/noalias assumptions, but keep Rust-like items (mod/use/pub), ADTs (struct/enum), match, methods via impl, traits + dyn trait objects, and we will add some Zig-style features.

I want this to eventually become the de-facto language for low-latency software applications.

# Lexing/parsing
Parse a Rust-2021-like subset with:
    No Generics!: this will be handled later
    Items: fn, struct, enum, trait, impl, type, const, static, mod, use, extern "C", attributes #[...] (you can ignore semantics initially).
    Expressions: literals, blocks, let, if/else, while, loop, match, calls, method calls, field access, indexing, casts as, unary *, binary ops, return, break, continue.
    Patterns: _, literals, Enum::Variant(pats...), tuple/struct destructuring, | alternatives, match guards if.
    Type system (brief reference-style spec)
    Kinds: value types and a comptime-only type kind (type-of-types).
    Primitive types: integers i8..i128, u8..u128, isize/usize, floats f32/f64, bool, char, unit ().
    Compound types: tuples (T...), arrays [T; N] where N is comptime usize, structs, enums (tagged unions).
    Include helpful types in std: Result(T, E) Option(T)
    Slices: const* [T] and mut* [T] are fat pointers (data pointer + length).
    Pointers:
        const* T, mut* T (may be null/dangling; may escape scope freely; just ordinary pointers).
        Coercions: mut* T -> const* T; scoped -> corresponding raw; raw -> scoped only via unsafe.
        Aliasing rule: mut* does NOT imply uniqueness; optimizer must assume pointers may alias. No noalias-based optimizations.
    Moves/Copy: move by default; Copy/Clone traits; reject use-after-move via local dataflow.
    Traits: no generics, no associated types. Methods may take self: const* Self / mut* Self (shorthand *const self, *mut self). 
    Trait objects exist as pointer-to-dyn: mut* dyn Trait, const* dyn Trait, raw variants. Vtables for dyn dispatch.
    Repr: support #[repr(C)]/#[repr(packed)]/etc.

# Type keyword
`type` is a first-class value used at compile-time to enable generic programming. 
    Type as a Value: types themselves are values that exist and can be manipulated at compile-time (comptime; more on that later).
    Generic Programming: It will be commonly used as a parameter type in a function signature to create generic functions or data structures. The compiler uses this to generate specialized versions of the function for each concrete type passed to it, e.g. Result(T, E) or Option(T) from above.
It can be placed either in a function signature like `fn add(comptime T: type, a: T, b: T) -> T` or as a return value `fn Option(comptime T: type) -> type`.

# Comptime
Implement comptime { ... } blocks evaluated at compile time.
Implement comptime fn runnable by the interpreter.
Allow comptime parameters: fn f(comptime N: usize, ...) specializing on constant arguments.
Support comptime returning values usable in const init, array lengths, and type aliases.
Comptime as generics: we want to support comptime functions returning
Reflection: builtin::type_info(type) -> TypeInfo, provides comptime reflection for types
Other builtins: builtin::size_of(type), builtin::align_of(type), builtin::compile_error(msg), builtin::addr_of(x)->const* T, builtin::addr_of_mut(x)->mut* T.

# Misc.
Build modes: similar ideas to Zig here - we want Debug, ReleaseSafe, ReleaseFast modes that provide runtime checking for
Complete C interop: 
    flawless C interop without FFI, we will eventually build a C => our language compiler
    should be able to pretty straightforwardly use C headers with some special syntax, e.g. use_interop

# Implementation plan (deliverable)
- First editions will be in C++ until we can bootstrap.
- Parser producing an AST for the subset above.
- Name resolution for modules/items and method lookup in impl blocks.
- Type checking with: structs/enums, match typing, method calls, trait method resolution, dyn dispatch typing, pointer rules (scoped vs raw), move checking.
- Lower to a simple IR.
- Lower to LLVM.
- Comptime interpreter capable of evaluating integer ops, control flow, arrays/structs/enums construction, and emitting compile_error.
- Codegen for a small standard prelude (basic ops, slices, and a few intrinsics).

To start, let's do a few things:
    (1) flesh out these ideas into a more comprehensive spec (i have a file spec.md ready for this).
    (2) build an agents.md for yourself
    (3) start drafting an example program in examples/
    (4) draft a formal grammar. 
        (4.1) install bison / flex into our c++ environment
        (4.2) use this on our example program
        (4.3) iterate on the grammar and example until we have a basic v0.0.1
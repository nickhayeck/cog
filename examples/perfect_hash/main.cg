// Minimal perfect hashing computed at comptime.
//
// This example builds three “perfect hash tables”:
// - `i32` keys -> `CStr` values
// - `f64` keys -> `i32` values
// - `CStr` keys -> opcodes (then dispatched via `match`)
//
// The perfect-hash *seed* and the “g table” are computed at comptime.
//
// v0.0.23+ note:
// This example also demonstrates “generic programming” via `fn ... -> type`:
// - `PhfMap(K, V)` returns a concrete struct type specialized to `K` and `V`.
// - The type is constructed at comptime using builtin type-construction.
//
// Current compiler limitation (important for the shape of this example):
// - Constructed types (`fn ... -> type` + `builtin::type_struct`) are not yet
//   supported in LLVM *global constant* emission, so we store the computed
//   tables in ordinary `static` items and build the `PhfMap(K, V)` values at
//   runtime as small structs of pointers.

mod phf;
mod cstr;

use phf::{Phf, MAX_KEYS};

// A C string is a thin pointer (`const* u8`), not a slice.
type CStr = const* u8;

// Fingerprints convert keys into stable integers for hashing.
fn fp_i32(x: i32) -> i64 { x as i64 }

// Fingerprint for floats: scale by 1000 and truncate. For an actual library you
// would want a bit-pattern hash, but that requires a bitcast story.
fn fp_f64(x: f64) -> i64 { (x * 1000.0) as i64 }

const SEED_LIMIT: i64 = 2000;

// ---- Generic “perfect hash map” type (computed at comptime) ----
//
// This is the generic part: we return a *type* specialized to `K` and `V`.
//
// The map stores pointers to:
// - a `phf::Phf` table (seed + g[])
// - the key array
// - the value array
//
// The key/value arrays are stored separately as statics so we don't need any
// runtime allocation.
fn PhfMap(comptime K: type, comptime V: type) -> type {
    let phf_ptr: type = builtin::type_ptr_const(Phf);
    let keys_ptr: type = builtin::type_ptr_const(builtin::type_slice(K));
    let values_ptr: type = builtin::type_ptr_const(builtin::type_slice(V));

    let fields = [
        builtin::StructField{
            name: "phf",
            ty: phf_ptr,
            vis: builtin::Vis::Pub,
        },
        builtin::StructField{
            name: "keys",
            ty: keys_ptr,
            vis: builtin::Vis::Pub,
        },
        builtin::StructField{
            name: "values",
            ty: values_ptr,
            vis: builtin::Vis::Pub,
        },
    ];

    let desc = builtin::StructDesc{
        name: "PhfMap",
        repr: builtin::StructRepr::Cog,
        fields: &fields,
    };

    builtin::type_struct(desc)
}

// ---- Map #1: i32 -> CStr ----

// Demonstrate “arbitrary values”: the map's value type can be any `Copy` type,
// including small structs.
struct StatusInfo {
    phrase: CStr,
    code_class: i32,
}

type IntMap = PhfMap(i32, StatusInfo);

static INT_KEYS: [i32; 9] = [200, 201, 204, 301, 400, 401, 403, 404, 500];
static INT_VALUES: [StatusInfo; 9] = [
    StatusInfo{phrase: c"OK", code_class: 2},
    StatusInfo{phrase: c"Created", code_class: 2},
    StatusInfo{phrase: c"No Content", code_class: 2},
    StatusInfo{phrase: c"Moved Permanently", code_class: 3},
    StatusInfo{phrase: c"Bad Request", code_class: 4},
    StatusInfo{phrase: c"Unauthorized", code_class: 4},
    StatusInfo{phrase: c"Forbidden", code_class: 4},
    StatusInfo{phrase: c"Not Found", code_class: 4},
    StatusInfo{phrase: c"Internal Server Error", code_class: 5},
];

static INT_PHF: Phf = comptime {
    let mut fps: [i64; MAX_KEYS] = [0; MAX_KEYS];
    let mut i: usize = 0;
    while i < 9 {
        fps[i] = fp_i32(INT_KEYS[i]);
        i = i + 1;
    };

    // We choose a non-minimal table size here (m=18) so the seed search is fast.
    let m: usize = 18;
    let mut seed: i64 = 0;
    let mut found: bool = false;
    while seed < SEED_LIMIT {
        let mut used: [bool; MAX_KEYS] = [false; MAX_KEYS];
        let mut ok: bool = true;
        let mut j: usize = 0;
        while j < 9 {
            let s: usize = phf::slot(m, fps[j], seed);
            if used[s] { ok = false; break; };
            used[s] = true;
            j = j + 1;
        };
        if ok { found = true; break; };
        seed = seed + 1;
    };
    if !found { builtin::compile_error("perfect hash seed search failed (i32 map)"); };

    let mut g: [usize; MAX_KEYS] = [0; MAX_KEYS];
    let mut j: usize = 0;
    while j < 9 {
        let s: usize = phf::slot(m, fps[j], seed);
        g[s] = j;
        j = j + 1;
    };

    Phf{n: 9, m: m, seed: seed, g: g}
};

fn int_map() -> IntMap {
    // `&[T; N]` implicitly coerces to `const* [T]` (a slice fat pointer).
    let keys: const* [i32] = &INT_KEYS;
    let values: const* [StatusInfo] = &INT_VALUES;
    IntMap{phf: &INT_PHF, keys: keys, values: values}
}

fn int_get_info(code: i32) -> StatusInfo {
    let m: IntMap = int_map();
    let idx: usize = phf::index(m.phf, fp_i32(code));
    if m.keys[idx] == code { m.values[idx] } else { StatusInfo{phrase: 0 as CStr, code_class: 0} }
}

fn int_get(code: i32) -> CStr {
    int_get_info(code).phrase
}

// ---- Map #2: f64 -> i32 ----

type FloatMap = PhfMap(f64, i32);

static FLOAT_KEYS: [f64; 6] = [0.5, 1.0, 2.0, 3.0, 10.0, 42.0];
static FLOAT_VALUES: [i32; 6] = [5, 10, 20, 30, 100, 420];

static FLOAT_PHF: Phf = comptime {
    let mut fps: [i64; MAX_KEYS] = [0; MAX_KEYS];
    let mut i: usize = 0;
    while i < 6 {
        fps[i] = fp_f64(FLOAT_KEYS[i]);
        i = i + 1;
    };

    // For this keyset, m=11 works well (and m=12 does not for this hash family).
    let m: usize = 11;
    let mut seed: i64 = 0;
    let mut found: bool = false;
    while seed < SEED_LIMIT {
        let mut used: [bool; MAX_KEYS] = [false; MAX_KEYS];
        let mut ok: bool = true;
        let mut j: usize = 0;
        while j < 6 {
            let s: usize = phf::slot(m, fps[j], seed);
            if used[s] { ok = false; break; };
            used[s] = true;
            j = j + 1;
        };
        if ok { found = true; break; };
        seed = seed + 1;
    };
    if !found { builtin::compile_error("perfect hash seed search failed (f64 map)"); };

    let mut g: [usize; MAX_KEYS] = [0; MAX_KEYS];
    let mut j: usize = 0;
    while j < 6 {
        let s: usize = phf::slot(m, fps[j], seed);
        g[s] = j;
        j = j + 1;
    };

    Phf{n: 6, m: m, seed: seed, g: g}
};

fn float_map() -> FloatMap {
    let keys: const* [f64] = &FLOAT_KEYS;
    let values: const* [i32] = &FLOAT_VALUES;
    FloatMap{phf: &FLOAT_PHF, keys: keys, values: values}
}

fn float_get(x: f64) -> i32 {
    let m: FloatMap = float_map();
    let idx: usize = phf::index(m.phf, fp_f64(x));
    if m.keys[idx] == x { m.values[idx] } else { -1 }
}

// ---- Map #3: CStr -> opcode ----
//
// v0.0.23 limitation: function pointer values are not supported in comptime
// evaluation yet, so we store a small opcode and dispatch with `match`.

fn cmd_inc(x: i32) -> i32 { x + 1 }
fn cmd_dec(x: i32) -> i32 { x - 1 }
fn cmd_double(x: i32) -> i32 { x * 2 }
fn cmd_half(x: i32) -> i32 { x / 2 }
fn cmd_square(x: i32) -> i32 { x * x }
fn cmd_neg(x: i32) -> i32 { -x }
fn cmd_abs(x: i32) -> i32 { if x < 0 { -x } else { x } }
fn cmd_xor42(x: i32) -> i32 { x ^ 42 }

fn cmd_apply(op: i32, x: i32) -> i32 {
    match op {
        0 => cmd_inc(x),
        1 => cmd_dec(x),
        2 => cmd_double(x),
        3 => cmd_half(x),
        4 => cmd_square(x),
        5 => cmd_neg(x),
        6 => cmd_abs(x),
        7 => cmd_xor42(x),
        _ => x,
    }
}

type CmdMap = PhfMap(CStr, i32);

static CMD_KEYS: [CStr; 8] = [
    c"inc",
    c"dec",
    c"double",
    c"half",
    c"square",
    c"neg",
    c"abs",
    c"xor42",
];

// Fingerprints for the keys above, computed offline using `cstr_hash_modp`.
// Once comptime pointer reads exist, these can be computed from the string
// literals directly.
static CMD_KEY_FPS: [i64; 8] = [
    6963514,     // inc
    6630956,     // dec
    558501453,   // double
    1771792283,  // half
    1072399358,  // square
    7291450,     // neg
    6432054,     // abs
    1402161075,  // xor42
];

static CMD_VALUES: [i32; 8] = [0, 1, 2, 3, 4, 5, 6, 7];

static CMD_PHF: Phf = comptime {
    let mut fps: [i64; MAX_KEYS] = [0; MAX_KEYS];
    let mut i: usize = 0;
    while i < 8 {
        fps[i] = CMD_KEY_FPS[i];
        i = i + 1;
    };

    // This one is minimal (m=n=8).
    let m: usize = 8;
    let mut seed: i64 = 0;
    let mut found: bool = false;
    while seed < SEED_LIMIT {
        let mut used: [bool; MAX_KEYS] = [false; MAX_KEYS];
        let mut ok: bool = true;
        let mut j: usize = 0;
        while j < 8 {
            let s: usize = phf::slot(m, fps[j], seed);
            if used[s] { ok = false; break; };
            used[s] = true;
            j = j + 1;
        };
        if ok { found = true; break; };
        seed = seed + 1;
    };
    if !found { builtin::compile_error("perfect hash seed search failed (cstr map)"); };

    let mut g: [usize; MAX_KEYS] = [0; MAX_KEYS];
    let mut j: usize = 0;
    while j < 8 {
        let s: usize = phf::slot(m, fps[j], seed);
        g[s] = j;
        j = j + 1;
    };

    Phf{n: 8, m: m, seed: seed, g: g}
};

fn cmd_map() -> CmdMap {
    let keys: const* [CStr] = &CMD_KEYS;
    let values: const* [i32] = &CMD_VALUES;
    CmdMap{phf: &CMD_PHF, keys: keys, values: values}
}

fn cmd_lookup(name: CStr) -> i32 {
    let m: CmdMap = cmd_map();
    let fp: i64 = cstr::cstr_hash_modp(name);
    let idx: usize = phf::index(m.phf, fp);
    if cstr::cstr_eq(m.keys[idx], name) { m.values[idx] } else { -1 }
}

fn main() -> i32 {
    // i32 map
    let a: CStr = int_get(404);
    let b: CStr = int_get(123);

    // f64 map
    let c: i32 = float_get(10.0);
    let d: i32 = float_get(1.5);

    // cstr -> opcode map
    let f: i32 = cmd_lookup(c"square");
    let g: i32 = cmd_lookup(c"nope");

    let mut out: i32 = 0;
    if a != 0 as CStr { out = out + 1; };
    if b == 0 as CStr { out = out + 2; };
    if c == 100 { out = out + 3; };
    if d == -1 { out = out + 4; };
    if f != -1 { out = out + cmd_apply(f, 7); };
    if g == -1 { out = out + 5; };

    out
}
